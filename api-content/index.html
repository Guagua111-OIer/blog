{"posts":[{"title":"P10710 [NOISG2024 Prelim] School Photo","content":"思路 这道题我们使用双指针来解。 我们将 aaa 数组拍平成一维数组，然后排序。利用 aaa 数组的有序性，维护两个指针 l,rl, rl,r 表示左边界与右边界。 接下来，我们会遇到两种情况：第一种，[l,r][l, r][l,r] 这个区间里没有包含所有的班级。这时我们将 rrr 自增。第二种，[l,r][l, r][l,r] 包含了所有的班级。这时更新答案 ansansans，并令 lll 自增以进一步寻找最优解。 问题是，如何 O(1)\\mathcal O(1)O(1) 判断区间里是否包含所有的班级呢？ 我们可以使用一个桶 ttt 来维护区间里每个教室的同学数量，并使用 sumsumsum 记录区间里不同教室的数量。这时我们写出以下代码： if (sum &lt; n) { //如果没有包含所有教室 r++; //右指针右移（新增一个同学） if (t[a[r].c] == 0) sum++; //如果这个同学来自一个新的教室，sum++ t[a[r].c]++; //他所在教师的人数 ++ } else { //如果包含了全部教室 ans = min(ans, a[r].h - a[l].h); //更新答案 t[a[l].c]--; //由于将要失去左边界的同学，所以教室人数 -- if (t[a[l].c] == 0) sum--; //这个教室没有学生了，意味着失去了一个教室，sum-- l++; //左边界右移 } 最后输出 ansansans 即可。 代码 #include &lt;algorithm&gt; //sort #include &lt;iostream&gt; //cin, cout using namespace std; int n, s, len, sum, t[1000005], ans = 0x7fffffff; struct Node { int c, h; //c 表示教室，h 表示身高 Node (int c = 0, int h = 0) : c(c), h(h) //构造函数 } a[1000005]; bool cmp(Node x, Node y) { //比较函数 return x.h &lt; y.h; } int main() { cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= s; j++) { int h; cin &gt;&gt; h; a[++len] = Node(i, h); //输入 } } sort(a + 1, a + len + 1, cmp); //排序 int l = 1, r = 0; //定义左边界与右边界 while (l &lt;= len &amp;&amp; r &lt;= len) { if (sum &lt; n) { r++; if (t[a[r].c] == 0) sum++; t[a[r].c]++; } else { ans = min(ans, a[r].h - a[l].h); t[a[l].c]--; if (t[a[l].c] == 0) sum--; l++; } } cout &lt;&lt; ans; //输出答案 return 0; } 如果这篇题解能够通过，那么就是我的第一篇题解了。希望大家多多指教，也希望管理员认真审核！ ","link":"https://Guagua111-OIer.github.io/blog/post/p10710-noisg2024-prelim-school-photo/"},{"title":"Quine —— 能够自我繁殖的程序生命","content":"你是否有过一个念头：“我要写一个能输出自己的程序！” 目的呢，可能是想要挑战、娱乐、炫耀。 但是，经过七七四十九般尝试，你依然没有研究出来这种程序。 不过，看完这篇文章，你就会 Get 到以前让你不敢相信的代码！ 那就让我们尝试写一写吧！ 提示：我是 C++ 党，所以本文的所有代码都是用 C++ 编写的。不过，尽管你不会 C++，只要读懂了思路，稍加变通，我相信你也一定能成功！ Part 1 一次大胆的尝试 首先，凡是代码都有框架：注：这里省略了主函数以外的部分与主函数\\texttt{\\tiny{注：这里省略了主函数以外的部分与主函数}}注：这里省略了主函数以外的部分与主函数 cout &lt;&lt; &quot;...&quot;; 然后，我们要将代码里的 ... 替换成整个代码，注意特殊字符的转义： cout &lt;&lt; &quot;cout &lt;&lt; \\&quot;...\\&quot;&quot;; emmm，又出现了一个 ...，按照规矩，我们应该把它也替换成整个代码。 cout &lt;&lt; &quot;cout &lt;&lt; \\&quot;cout &lt;&lt; \\&quot;cout &lt;&lt; \\&quot;...\\&quot;\\&quot;;\\&quot;&quot;; emmm，还有一个 ...，所以继续替换…… 等等，你有没有发现什么不对劲的地方？ Part 2 无法打破的 “造物论” 看着上方越来越长的代码，你不禁陷入深思。 照这么写，我的代码要写 INF 列啊！！！QWQ 注:INF是无穷大的意思。\\texttt{\\tiny{注:INF是无穷大的意思。}}注:INF是无穷大的意思。 我们貌似发现了一个无法打破的理论，我们暂且称之为 “造物论”。该理论指出，任何一种物质，都只能由比其跟高级的物质造出。例如，汽车厂造出汽车，人类造出玩具。（我们的程序也可以由 Windows 强大的文件读写特性直接输出代码文件自己，但是过程中利用了 Windows 这种比代码复杂 10000 倍的东西，并没有违背定理。） 所以貌似 “造物论” 开始阻拦我们的实现了。 但是，“造物论” 真的就无法打破吗？ 答案是否定的。 Part 3 自我繁殖的奥秘 微生物的繁殖，人类繁衍后代，植物授粉，无一不在做 “造物论” 的反例！大自然，就是我们成功的一丝希望！ 程序，也可以用类似的方法进行繁殖。 #include&lt;cstdio&gt; char s[]=&quot;#include&lt;cstdio&gt;%cchar s[]=%c%s%c;%cint main(){printf(s,10,34,s,34);}&quot;; int main(){printf(s,10,34,s,34,10);} 我们可以先输出代码其他部分，将会重复的那一行单独存下来，通过 printf() 的特性将 sss 的重复部分用 sss 替代。 %c 是指代特殊字符。因为特殊字符转义是包含两个字符，所以为了方便，我们用 %c 表示特殊字符。 %s 是字符串重复的位置，我们通过 printf() 将重复的部分替换。 以上代码看上去码风很丑，不过这是为了使最后代码简洁。因为一旦加长代码，就会使 sss 的长度增加。 通过这种 “先将重复部分存下来不管，输出其他部分，最后在其他语句中将重复部分替换” 的思路，我们可以衍生出很多很多代码。比如这个： 把括号里的内容抄一遍，再带括号抄一遍，最后加个句号（把括号里的内容抄一遍，再带括号抄一遍，最后加个句号）。 自然语言 大家可以发现，按照这段话做一遍后，你会得到一个一模一样的段落！ 还有很多 Quine 程序的实现。大家可以查阅资料。能输出自己的程序，就这样被我们创造出来了！是不是不敢相信？到此，我们大功告成！ EndEndEnd ","link":"https://Guagua111-OIer.github.io/blog/post/Quine/"}]}